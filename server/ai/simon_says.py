import asyncio
import websockets
import json
import argparse
import random
import operator
import colorsys
import itertools
import math


import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import map
import unit
import combat
import status
from game import Game

class AI:
    """
    The basic idea of this AI is to reduce the complexity by dividing the own phase 
    into three subphases (attack, assault, maneuver) and thus divide the overall problem 
    into smaller, more easily solvable problems. This should enable the application of 
    depth-limited search, especially for attack and assault actions, while maintaining 
    a reasonable runtime.

    Notes
    -----
    The AI tends to act passively and avoid fights if its own losses are greater than 
    those of the enemy units. Therefore, particularly aggressive AIs, such as agg, show 
    better final scores in certain situations. A long-term view of the score is not 
    considered to justify higher losses than those of the enemy in individual cases,
    for example if a city can be captured for it.

    The development is based on the scenarios generated by the scenario generator 
    'invasion', which only uses infantry units and the terrain 'Urban' and 'Clear'. 
    Some methods have been simplified for this special case due to the limited 
    development time. Therefore, unwanted actions may be performed when using other 
    unit and terrain types. 

    Description
    -----------
    The set-up algorithm prefers proximity to cities, but in addition to seeking to 
    minimize the distance to the closest city from a potential hex position, it 
    considers a weighted score of the distance to all cities so that the AI prefers 
    setting up near groups of cities over widely separated cities.
    
    Execution is divided into three sub-phases, Attack, Assault, Maneuver, executed in 
    that order.

    The Attack sub-phase creates a set of the friendly units which are ‘in range’ or 
    adjacent to opposing units, and thus eligible to attack on that turn. Units within 
    this set that share a potential target are further grouped into ‘battlegroup’ sets. 
    Battlegroups are capped at three members for performance considerations. For each 
    battlegroup, full ply search of all potential moves of battlegroup units is applied 
    examining the agent’s turn and the following enemy reaction turn. The branching 
    factor of this search is intentionally limited by considering only actions of ‘fire’ 
    or ‘move’ to a hex out of enemy range for the agent’s own forces and considering 
    only ‘fire’ actions targeting units within the considered battlegroup for enemy 
    units. The combination of actions resulting in the best score are sent to the game 
    in sequence for execution before repeating the process for the next battlegroup. The 
    subphase ends when all units in the ‘in range’ set have taken an action.

    In the Assault sub-phase, friendly units which have a current strength of at least 75
    and an available move to be adjacent to an enemy unit are considered. Similar to the 
    previous sub-phase, units which can move adjacent to the same enemy unit are grouped 
    into assault groups of no more than three units. Each assault group is considered 
    with a full ply search of the friendly turn for movement into contact, the enemy 
    reaction turn, and the following friendly turn where attack is possible. To limit the 
    branch factor of this search, only ‘move’ actions to hexes within range of the enemy 
    are considered on the initial friendly turn, only ‘fire’ actions targeting friendly 
    members of the assault group are considered on the enemy turn, and only ‘fire’ actions 
    by assault group members are considered on the follow-on friendly turn. The first 
    sequence of actions wherein the damage taken by friendly forces is exceeded by the 
    damage dealt on the next turn is sent to the game in sequence for execution. By taking 
    the first feasible solution rather than seeking optimization, the depth of search is 
    further limited. The sub-phase ends when all units in all assault groups have been 
    considered for movement.

    The Maneuver sub phase considers all friendly units that have yet to take an action 
    on an individual basis. Units move toward the best scored hex, based on the distances 
    to not captured cities, enemy and friendly units, current strength and remaining 
    phases.

    Modified Methods
    ----------------
    __init__(self, role, kwargs={}):
        + original source: pass_agg.py
        + initialization of additionally needed global variables
    process(self, message, response_fn=None):
        + original source: pass_agg.py
        + added setup phase and action_queue similar to setup_demo_orig.py
    _setupActions(self,cityOwnerD):
        + original source: setup_demo_orig.py
        + different scoring for setup hexes based on closest distance to the cities and sum of distances to all cities

    Added Methods
    -------------
    getEuclideanDistToClosestEnemyCity(self, actor, hex):
        + modified version of euclideanDistanceToCities(self, actor, hex) from burtplus.py
        + return the euclidean distance to the closest of the enemy cities
    getHexDistToClosestEnemyCity(self, hx):
        + return hex distance to the closest enemy city for a given hex and the hex of this city
    getScoreHexDistToCities(self, hx, cityOwnerD):
        + return a score for a given hex based on the hex distance to the closest city and the sum of the hex distances to all cities
    getTotalHexDistToCities(self,hx,cityOwnerD):
        + return the sum of the hex distances to all cities for a given hex
    getHexDistToClosestCity(self,hx,cityOwnerD):
        + return the hex distance to the closest city
    getNumberUnitsAroundHex(self, hex, range):
        + return the number of friendly and enemy units in given hex range around the given hex
    getBestUnitManeuverAction(self, unt, remainingPhases, noGoHex= set()):
        + return the best scored maneuver action for the given unit
    getWorstCaseCounterAttackActions(self, game, state, battlegroup, battlegroup_strength, starting_score, starting_score_opfor = None):
        + Find the worst combination of opfor fire actions as reaction to the own last move
    getBestBattlegroupAttackActions(self, game, state, battlegroup, enyNextHexId = set(), battlegroup_strength = None, starting_score=None, target_strength = None):
        + Return the best attack actions for a given battlegroup based on a depth-limited search
    getBestAssaultGroupAttackActions(self, game, state, assaultgroupId, starting_score, target_strength = None):
        + Find the best score for the first fire of friendly units after assaulting the enemy units and get shoot
    getWorstCaseAttackActionsOnAssaultGroup(self, game, state, assaultgroupId, starting_score, assaultgroup_strength, starting_score_opfor = None):
        + Find the worst combination of opfor fire actions as reaction to the own last move
    getBestAssaultGroupAssaultActions(self, game, state, assaultgroupId, assaultgroupTargetHex,starting_score=None, assaultgroup_strength = None):
        + Find the best actions for the given assaultgroup
    getPendingUnitsNextActions(self, game, state):
        + Find the best actions for the remaining not moved units in this phase.
        
    References
    ----------
    Initial source code was based on pass_agg.py, setup_demo_orig.py, stomp.py, burtplus.py

    @author Simon Schnitzler
    """
    def __init__(self, role, kwargs={}):
        self.role = role
        self.mapData = None
        self.unitData = None
        self.mode = kwargs.get("mode",None)
        # different categories of units to handle with in each turn
        self.unitsInRange = set() # Units which have potential targets
        self.unitsGetInRange = set() # Units which could move into the range of an enemy unit
        self.unitsManeuver = set() # Units which have no potential targets and can not move into the range of an enemy unit
        # list to save the resulting sequence of actions
        self.best_action_list = []
        self.hasAssaulted = False     
    
    def getHexDistToClosestEnemyCity(self,hx):
        '''
        Return the closest hexDistance to enemy cities and the hex of this city for a given hex
        '''
        hx_x, hx_y = hx.x_offset, hx.y_offset
        closestDist = float('inf')
        closestHex = None
        for city_id in self.statusData.ownerD:
            if self.statusData.ownerD[city_id] == self.role:
                continue
            city_hex = self.mapData.hexIndex[city_id]
            dist = map.hexDistance(hx_x,hx_y,city_hex.x_offset,city_hex.y_offset)
            if dist < closestDist:
                closestDist = dist
                closestHex = city_hex
        return closestDist, closestHex

    def getScoreHexDistToCities(self,hx,cityOwnerD):
        '''
        Sum up all distances to the cities and add this value multiplied with a weight to the closest distance
        '''
        hx_x, hx_y = hx.x_offset, hx.y_offset
        centerOfGravityFactor = 0.01
        totalDist = 0
        closestDist = float('inf')
        for city_id in cityOwnerD:
            city_hex = self.mapData.hexIndex[city_id]
            dist = map.hexDistance(hx_x,hx_y,city_hex.x_offset,city_hex.y_offset)
            closestDist = min(closestDist,dist)
            totalDist += dist
        return closestDist + (centerOfGravityFactor * totalDist)
    
    def getTotalHexDistToCities(self,hx,cityOwnerD):
        '''
        Sum up all hex distances to all cities of the scenario
        '''
        hx_x, hx_y = hx.x_offset, hx.y_offset
        totalDist = 0
        for city_id in cityOwnerD:
            city_hex = self.mapData.hexIndex[city_id]
            totalDist += map.hexDistance(hx_x,hx_y,city_hex.x_offset,city_hex.y_offset)
        return totalDist
     
    def getHexDistToClosestCity(self,hx,cityOwnerD):
        '''
        Return the hex distance to the closest city of all cities
        '''
        hx_x, hx_y = hx.x_offset, hx.y_offset
        closestDist = float('inf')
        for city_id in cityOwnerD:
            city_hex = self.mapData.hexIndex[city_id]
            dist = map.hexDistance(hx_x,hx_y,city_hex.x_offset,city_hex.y_offset)
            closestDist = min(closestDist,dist)
        return closestDist
    
    def _setupActions(self,cityOwnerD):
        '''
        Return a list with setup actions for all friendly units based on the hex 
        distances to the cities in the scenario.

        First for every city in the scenario the closest setup hex is selected for 
        placing one unit. The remaining units are placed on the best scored setup hexes 
        based on the hex distance to the closest city and the sum of the hex distances 
        to all cities.
        '''
        actions = []
        destinations = []
        setup_hexes = self.mapData.getSetupHexes(self.role)
        # for every not occupied city find the closest hex
        for city_id in cityOwnerD:
            if self.statusData.ownerD[city_id] == self.role:
                    continue
            closestDist = float('inf')
            closestHex = None
            city_hex = self.mapData.hexIndex[city_id]
            for hex in setup_hexes:
                hx_x, hx_y = hex.x_offset, hex.y_offset      
                dist = map.hexDistance(hx_x,hx_y,city_hex.x_offset,city_hex.y_offset)
                if dist < closestDist:
                    closestDist = dist
                    closestHex = hex
            if closestHex:
                destinations.append(closestHex)
                setup_hexes.remove(closestHex)


        # remaining units are set to the hexes closest to the most cities
        for hx in setup_hexes:
            #hx.closestCityDist = self.getHexDistToClosestCity(hx,cityOwnerD)
            #hx.closestCityDist = self.getTotalHexDistToCities(hx,cityOwnerD)
            hx.closestCityDist = self.getScoreHexDistToCities(hx,cityOwnerD)
        setup_hexes.sort(reverse=True,key=lambda x:x.closestCityDist)
        units = self.unitData.getFaction(self.role)
        while units:
            moving_unit = units.pop()
            if destinations:
                destination = destinations.pop()
            else:
                destination = setup_hexes.pop()
            actions.append( (moving_unit.uniqueId, destination.id) )
        return actions
    
    def getEuclideanDistToClosestEnemyCity(self, actor, hex):
        '''
        Return the euclidean distance to the closest of the enemy cities
        '''
        xA = hex.x_grid
        yA = hex.y_grid
        closest_dist = float('inf')
        if self.statusData.ownerD:
            for city_id in self.statusData.ownerD:
                if self.statusData.ownerD[city_id] == actor.faction:
                    continue
                xB = self.mapData.hexIndex[city_id].x_grid
                yB = self.mapData.hexIndex[city_id].y_grid
                dist = map.gridDistance(xA,yA,xB,yB)
                if dist < closest_dist:
                    closest_dist = dist  
        return closest_dist
    
    def euclideanDistanceToOpfor(self, actor, hex):
        xA = hex.x_grid
        yA = hex.y_grid
        closest = None
        closest_dist = float('inf')
        if not self.unitData.units():
            return float('inf')
        for target in self.unitData.units():
            if target.faction == actor.faction or target.ineffective or not target.hex:                 continue
            xB = target.hex.x_grid
            yB = target.hex.y_grid
            dist = map.gridDistance(xA,yA,xB,yB)
            if dist < closest_dist:
                closest_dist = dist
                closest = target
        return closest_dist
    def euclideanDistanceToCities(self, actor, hex):
        if actor.faction=="red":
            opfor = "blue"
        else:
            opfor = "red"
        xA = hex.x_grid
        yA = hex.y_grid
        closest_dist = float('inf')
        if self.statusData.ownerD:
            for city_id in self.statusData.ownerD:
                xB = self.mapData.hexIndex[city_id].x_grid
                yB = self.mapData.hexIndex[city_id].y_grid
                dist = map.gridDistance(xA,yA,xB,yB)
                if dist < closest_dist:
                    closest_dist = dist  
        return closest_dist
    
    def getNumberUnitsAroundHex(self, hex, range):
        '''
        Return the number of friendly and enemy units in given hex range around the given hex
        '''
        numberOwnUnits = 0
        numberEnemyUnits = 0
        for unit in self.unitData.units():
            if unit.faction != self.role and not unit.ineffective:
                dist = map.gridDistance(hex.x_grid, hex.y_grid, unit.hex.x_grid, unit.hex.y_grid)
                if dist <= range:
                    numberEnemyUnits += 1
            if unit.faction == self.role and not unit.ineffective:
                dist = map.gridDistance(hex.x_grid, hex.y_grid, unit.hex.x_grid, unit.hex.y_grid)
                if dist <= range:
                    numberOwnUnits += 1
        return numberOwnUnits, numberEnemyUnits
    
    
    def getBestUnitManeuverAction(self, unt, remainingPhases, noGoHex= set()):
        '''
        If the unit has a current strength greater than the specified minimum assault strength,
        then the unit chooses the closest not captured city or enemy as a target. The unit
        will move to the hex nearest to the target.
        If the unit has a current strength less than the specified minimum assault strength,
        then the unit chooses the closest not captured city with no closer enemy or friendly
        unit. Otherwise the closest own city with less own units than enemy units is
        choosen as move target. 
        '''
        MAX_OVERMATCH = 2
        MIN_ASSAULT_STRENGTH = 75

        targetHex = None
        targetDist = remainingPhases
        moveTargets = unt.findMoveTargets(self.mapData, self.unitData)
        if not moveTargets:
            return None
    
        # maneuver in direction of nearest enemy units or not captured enemy city
        if unt.currentStrength >= MIN_ASSAULT_STRENGTH:
            distClosestEnyCity, hexClosestEnyCity = self.getHexDistToClosestEnemyCity(unt.hex)
            if distClosestEnyCity <= targetDist:
                targetDist = distClosestEnyCity
                targetHex = hexClosestEnyCity
            for eny in self.unitData.units():
                if eny.faction != self.role and not eny.ineffective:
                    distance = map.hexDistance(unt.hex.x_offset, unt.hex.y_offset, eny.hex.x_offset, eny.hex.y_offset)
                    if distance < targetDist:
                        enyInRange = 1
                        ownInRange = 1
                        for unit in self.unitData.units():
                            if unit.faction != self.role and not unit.ineffective and eny != unit:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, eny.hex.x_offset, eny.hex.y_offset)
                                if dist <= distance:
                                    enyInRange += 1
                            if unit.faction == self.role and unit.currentStrength >= MIN_ASSAULT_STRENGTH and unt != unit:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, eny.hex.x_offset, eny.hex.y_offset)
                                if dist <= distance:
                                    ownInRange += 1
                        if ownInRange <= enyInRange + MAX_OVERMATCH:
                            targetHex = eny.hex
                            targetDist = distance
        else:
            closestOwnCityDist = remainingPhases
            closestEnyCityDist = remainingPhases
            closestOwnCityHex = None
            closestEnyCityHex = None
            for city_id in self.statusData.ownerD:
                if self.statusData.ownerD[city_id] == self.role:
                    city_hex = self.mapData.hexIndex[city_id]
                    city_dist = map.hexDistance(unt.hex.x_offset,unt.hex.y_offset,city_hex.x_offset,city_hex.y_offset)
                    if city_dist < closestOwnCityDist:
                        enyInRange = 0
                        ownInRange = 1
                        for unit in self.unitData.units():
                            if unit.faction != self.role and not unit.ineffective:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, city_hex.x_offset, city_hex.y_offset)
                                if dist < city_dist:
                                    enyInRange += 1
                            if unit.faction == self.role and not unit.ineffective and unt != unit:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, city_hex.x_offset, city_hex.y_offset)
                                if dist < city_dist:
                                    ownInRange += 1
                            if ownInRange < enyInRange:
                                closestOwnCityDist = city_dist
                                closestOwnCityHex = city_hex
                if self.statusData.ownerD[city_id] != self.role:
                    city_hex = self.mapData.hexIndex[city_id]
                    city_dist = map.hexDistance(unt.hex.x_offset,unt.hex.y_offset,city_hex.x_offset,city_hex.y_offset)
                    if city_dist < closestEnyCityDist:
                        enyInRange = 0
                        ownInRange = 1
                        for unit in self.unitData.units():
                            if unit.faction != self.role and not unit.ineffective:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, city_hex.x_offset, city_hex.y_offset)
                                if dist < city_dist:
                                    enyInRange += 1
                            if unit.faction == self.role and not unit.ineffective and unt != unit:
                                dist = map.hexDistance(unit.hex.x_offset, unit.hex.y_offset, city_hex.x_offset, city_hex.y_offset)
                                if dist < city_dist:
                                    ownInRange += 1
                            if enyInRange == 0 and ownInRange == 0:
                                closestEnyCityDist = city_dist
                                closestEnyCityHex = city_hex
            if closestEnyCityHex:
                targetHex = closestEnyCityHex
            elif closestOwnCityHex:
                targetHex = closestOwnCityHex
                  
        if targetHex:
            min_dist = targetDist
            best_hex = None
            for hex in moveTargets:
                if not noGoHex.isdisjoint({hex.id}):
                    continue             
                dist = map.hexDistance(hex.x_offset, hex.y_offset, targetHex.x_offset, targetHex.y_offset)
                # prevent the abandonment of the better terrain if the improvement is only minimal
                if min_dist == dist and unt.hex.terrain == "urban" and hex.terrain != "urban":
                    continue
                if dist <= min_dist:
                    min_dist = dist
                    best_hex = hex
            if best_hex:
                return {"type":"move", "mover":unt.uniqueId, "destination":best_hex.id, }

        return None
    
    def getWorstCaseCounterAttackActions(self, game, state, battlegroup, battlegroup_strength, starting_score, starting_score_opfor = None):
        '''
        Find the worst combination of opfor fire actions as reaction to the own last move (principle of min max algorithm in combination with getBestBattlegroupAttackActions)
        reduce the complexity by using only fire actions of the identified targets (Note: artillery is not implemented yet)
        
        TODO implement move actions occupying a city (not implemented yet)
        '''
        if starting_score_opfor is None:
            starting_score_opfor = state["status"]["score"]
        worst_actions = []
        legal_actions = game.legal_actions(state)
        legal_target_actions = []
        for action in legal_actions:
            if (action["type"]=="fire" and not battlegroup.isdisjoint({action["target"]})):
                legal_target_actions.append(action)
        if not legal_target_actions or state["status"]["onMove"]==self.role:
            return [], state["status"]["score"]-starting_score
        if self.role == "red":
            worst_score = float("-inf")
            comparison_op = operator.gt
        else:
            worst_score = float("inf")
            comparison_op = operator.lt
        for action in legal_target_actions:
            postaction_state = game.transition(state, action)
            if postaction_state["status"]["onMove"]==self.role:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                score = state["status"]["score"]- (starting_score + city_score) # consider enemy turn
                actions = [action]
            else:
                actions, score = self.getWorstCaseCounterAttackActions(game,postaction_state, battlegroup, battlegroup_strength, starting_score, starting_score_opfor)
                actions.append(action)
            #alpha beta pruning
            if battlegroup_strength <= abs(score - starting_score_opfor) + 1:
                return actions, score

            if comparison_op(score,worst_score):
                worst_actions, worst_score = actions, score
        return worst_actions, worst_score

    def getBestBattlegroupAttackActions(self, game, state, battlegroup, enyNextHexId = set(), battlegroup_strength = None, starting_score=None, target_strength = None):
        '''
        Return the best attack actions for a given battlegroup based on a depth-limited 
        search considering the friendly attack actions in this phase and the worst case fire 
        actions of the remaining enemy units targeting the battlegroup units.

        TODO if shooting and withdraw result in the same score, than shooting should be preferred (at this staus the first found action series will be preferred)
        '''
        if battlegroup_strength is None:
            battlegroup_strength = 0
            for unt in self.unitData.units():
                if not battlegroup.isdisjoint({unt.uniqueId}):
                    battlegroup_strength += unt.currentStrength
            
        if starting_score is None:
            starting_score = state["status"]["score"]
        legal_actions = game.legal_actions(state)
        legal_bg_actions = []
        for action in legal_actions:
            if (action["type"]=="move" and not battlegroup.isdisjoint({action["mover"]}) and enyNextHexId.isdisjoint({action["destination"]})) or (action["type"]=="fire" and not battlegroup.isdisjoint({action["source"]})):
                legal_bg_actions.append(action)
        if target_strength is None:
            target_strength = 0
            targets = set()
            for action in legal_bg_actions:
                if action["type"]=="fire":
                    targets.add(action["target"])
            for unt in self.unitData.units():
                if not targets.isdisjoint({unt.uniqueId}):
                    target_strength += unt.currentStrength

        if not legal_bg_actions or state["status"]["onMove"]!=self.role:
            postaction_state = game.transition(state, {"type":"pass"}) # finish phase and collect score for cities
            city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
            _ , worst_score = self.getWorstCaseCounterAttackActions(game,postaction_state, battlegroup, battlegroup_strength, starting_score + city_score) # consider enemy turn
            return [], worst_score
        
        best_actions = []
        if self.role == "blue":
            best_score = float("-inf")
            comparison_op = operator.gt
        else:
            best_score = float("inf")
            comparison_op = operator.lt
        for action in legal_bg_actions:
            postaction_state = game.transition(state, action)
            if postaction_state["status"]["onMove"]!=self.role:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                _ , score = self.getWorstCaseCounterAttackActions(game,postaction_state, battlegroup, battlegroup_strength, starting_score + city_score) # consider enemy turn
                actions = [action]
            # kind of alpha beta pruning
            elif target_strength <= abs(postaction_state["status"]["score"] - starting_score) + 1:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                _ , score = self.getWorstCaseCounterAttackActions(game,postaction_state, battlegroup, battlegroup_strength, starting_score + city_score) # consider enemy turn
                actions = [action]
                return actions, score
            else:
                actions, score = self.getBestBattlegroupAttackActions(game,postaction_state, battlegroup, enyNextHexId, battlegroup_strength, starting_score, target_strength)
                actions.append(action)
            if comparison_op(score,best_score):
                best_actions, best_score = actions, score
        return best_actions, best_score
    
    def getBestAssaultGroupAttackActions(self, game, state, assaultgroupId, starting_score, target_strength = None):
        '''
        Find the best score for the first fire of friendly units after assaulting the enemy units and get shoot
        '''
        legal_actions = game.legal_actions(state)
        legal_counterattack_actions = []
        for action in legal_actions:
            if (action["type"]=="fire" and not assaultgroupId.isdisjoint({action["source"]})):
                legal_counterattack_actions.append(action)

        if target_strength is None:
            target_strength = 0
            targets = set()
            for action in legal_counterattack_actions:
                if action["type"]=="fire":
                    targets.add(action["target"])
            for unt in self.unitData.units():
                if not targets.isdisjoint({unt.uniqueId}):
                    target_strength += unt.currentStrength

        if not legal_counterattack_actions or state["status"]["onMove"]!=self.role:
            return [], state["status"]["score"] -starting_score
        best_actions = []
        if self.role == "blue":
            best_score = float("-inf")
            comparison_op = operator.gt
        else:
            best_score = float("inf")
            comparison_op = operator.lt
        for action in legal_counterattack_actions:
            postaction_state = game.transition(state, action)
            if postaction_state["status"]["onMove"]!=self.role:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                score = state["status"]["score"] - (starting_score + city_score)
                actions = [action]
            # kind of alpha beta pruning
            elif target_strength <= abs(postaction_state["status"]["score"] - starting_score) + 1:
                actions = [action]
                return actions, postaction_state["status"]["score"] - starting_score
            else:
                actions, score = self.getBestAssaultGroupAttackActions(game,postaction_state, assaultgroupId, starting_score, target_strength)
                actions.append(action)
            if comparison_op(score,best_score):
                best_actions, best_score = actions, score
        return best_actions, best_score
    
    def getWorstCaseAttackActionsOnAssaultGroup(self, game, state, assaultgroupId, starting_score, assaultgroup_strength, starting_score_opfor = None):
        '''
        Find the worst combination of opfor fire actions as reaction to the own last move (principle of min max algorithm in combination with getBestBattlegroupAttackActions)
        Reduce the complexity by using only fire actions of the identified targets (Note: artillery is not implemented yet)
        
        TODO implement move actions occupying a city (not implemented yet)
        TODO combine getWorstCaseAttackActionsOnAssaultGroup with getWorstCaseCounterAttackActions
        '''
        if starting_score_opfor is None:
            starting_score_opfor = state["status"]["score"]
        worst_actions = []
        legal_actions = game.legal_actions(state)
        legal_target_actions = []
        for action in legal_actions:
            if (action["type"]=="fire" and not assaultgroupId.isdisjoint({action["target"]})):
                legal_target_actions.append(action)
        if not legal_target_actions or state["status"]["onMove"]==self.role:
            postaction_state = game.transition(state, {"type":"pass"}) # finish phase and collect score for cities
            city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
            _ , best_score = self.getBestAssaultGroupAttackActions(game,postaction_state, assaultgroupId, starting_score + city_score) # consider own fire
            return [], best_score
        if self.role == "red":
            worst_score = float("-inf")
            comparison_op = operator.gt
        else:
            worst_score = float("inf")
            comparison_op = operator.lt
        for action in legal_target_actions:
            postaction_state = game.transition(state, action)
            if postaction_state["status"]["onMove"]==self.role:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                _ , score = self.getBestAssaultGroupAttackActions(game,postaction_state, assaultgroupId, starting_score + city_score) # consider enemy turn
                actions = [action]
            else:
                actions, score = self.getWorstCaseAttackActionsOnAssaultGroup(game,postaction_state, assaultgroupId, starting_score, assaultgroup_strength, starting_score_opfor)
                actions.append(action)
            #alpha beta pruning
            if assaultgroup_strength <= abs(score - starting_score_opfor) + 1:
                return actions, score
            
            if comparison_op(score,worst_score):
                worst_actions, worst_score = actions, score
        return worst_actions, worst_score
    
    def getBestAssaultGroupAssaultActions(self, game, state, assaultgroupId, assaultgroupTargetHex,starting_score=None, assaultgroup_strength = None):
        '''
        Find the best actions for the given assaultgroup

        Recursive Approach:
        + max the score for the movement of the assaultgroup
        + min the score for the enemy fire
        + max the score for the fire of the own troops
        '''
        if assaultgroup_strength is None:
            assaultgroup_strength = 0
            for unt in self.unitData.units():
                if not assaultgroupId.isdisjoint({unt.uniqueId}):
                    assaultgroup_strength += unt.currentStrength
        if starting_score is None:
            starting_score = state["status"]["score"]
        legal_actions = game.legal_actions(state)
        legal_assault_actions = []
        for action in legal_actions:
            if (action["type"]=="move" and not assaultgroupId.isdisjoint({action["mover"]}) and not assaultgroupTargetHex.isdisjoint({action["destination"]})) or action["type"]=="pass":
                legal_assault_actions.append(action)
        if not legal_assault_actions or state["status"]["onMove"]!=self.role:
            postaction_state = game.transition(state, {"type":"pass"}) # finish phase and collect score for cities
            city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
            _ , worst_score = self.getWorstCaseAttackActionsOnAssaultGroup(game,postaction_state, assaultgroupId, starting_score + city_score) # consider enemy turn
            return [], worst_score
        
        best_actions = []
        if self.role == "blue":
            best_score = float("-inf")
            comparison_op = operator.gt
        else:
            best_score = float("inf")
            comparison_op = operator.lt
        for action in legal_assault_actions:
            postaction_state = game.transition(state, action)
            if action == {"type":"pass"}:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                _ , score = self.getWorstCaseAttackActionsOnAssaultGroup(game,postaction_state, assaultgroupId, starting_score + city_score, assaultgroup_strength) # consider enemy turn
                actions = []
            # all units are moved and pass action automatically triggered
            elif postaction_state["status"]["onMove"]!=self.role:
                city_score = postaction_state["status"]["score"] - state["status"]["score"] # discard the additional score for the cities, otherwise weak advantages are not used
                _ , score = self.getWorstCaseAttackActionsOnAssaultGroup(game,postaction_state, assaultgroupId, starting_score + city_score, assaultgroup_strength) # consider enemy turn
                actions = [action]
            else:
                actions, score = self.getBestAssaultGroupAssaultActions(game,postaction_state, assaultgroupId,assaultgroupTargetHex, starting_score, assaultgroup_strength)
                actions.append(action)

            if comparison_op(score,best_score):
                best_actions, best_score = actions, score
        return best_actions, best_score
    
    def getPendingUnitsNextActions(self, game, state):
        '''
        Find the best actions for the remaining not moved units in this phase.

        Approach:
        1. Find all friendly units, which could attack an enemy unit, and find the best attack actions for them.
        2. Find all friendly units, which could move into the range to attack enemy units in the next round, and find the best assault actions for them.
        3. Find the best maneuver action for the remaining not moved friendly units.
        '''
        MAX_GROUPSIZE = 3
        MIN_ASSAULT_STRENGTH = 75

        # TODO better solution for finding hexes in ranges of enemy units as no go area for maneuvering. Is only working if all movements are one hex
        enyNextHexId = set()

        # Divide the units into three categories (InRange, GetInRange, Maneuver) for the diffrent action finding strategy
        self.unitsInRange = set() # Units which have potential targets
        
        # find unitsInRange and calculate all empty hexes next to enemy units
        for unt in self.unitData.units():
            if unt.faction == self.role and unt.canMove and not unt.ineffective:
                fireTargets = unt.findFireTargets(self.unitData)
                if fireTargets:
                    enyNextHexId.add(unt.hex.id)
                    self.unitsInRange.add(unt)
            if unt.faction != self.role and not unt.ineffective:
                nextHexes = map.getNeighborHexes(unt.hex, self.mapData)
                for hex in nextHexes:
                    enyNextHexId.add(hex.id)

        # subdivide unitsInRange into Battlegroups by checking if they share at least one common target
        if len(self.unitsInRange) > 0:
            battlegroup = set()
            battlegroupId = set()
            targets = set()
            discardedTargets = set()
            
            while len(battlegroup) == 0 or not targets.isdisjoint(discardedTargets):
                discardedTargets = set()
                for unt in self.unitsInRange:
                    if len(battlegroup) == 0:
                        battlegroup.add(unt)
                        battlegroupId.add(unt.uniqueId)
                        targets.update(unt.findFireTargets(self.unitData))
                        continue
                    newTargets = unt.findFireTargets(self.unitData)
                    if not targets.isdisjoint(newTargets):
                        targets.update(newTargets)
                        battlegroup.add(unt)
                        battlegroupId.add(unt.uniqueId)
                    else:
                        discardedTargets.update(newTargets)
                self.unitsInRange.difference_update(battlegroup)
            
            if len(battlegroup) <= MAX_GROUPSIZE:
                best_actions, _ = self.getBestBattlegroupAttackActions(game, state, battlegroupId, enyNextHexId)
                return best_actions
            else:
                subsets = set(itertools.combinations(battlegroup, MAX_GROUPSIZE))
                best_actions = []
                if self.role == "blue":
                    best_score = float("-inf")
                    comparison_op = operator.gt
                else:
                    best_score = float("inf")
                    comparison_op = operator.lt
                for subset in subsets:
                    actions, score = self.getBestBattlegroupAttackActions(game, state, battlegroupId, enyNextHexId)
                    return actions
                    #if score >= 0 and self.role == "blue":     
                    #    return actions
                    #if score <= 0 and self.role == "red":
                    #    return actions
                    if comparison_op(score,best_score):
                        best_actions, best_score = actions, score
                return best_actions
        
        #--------------------------------------------------------------------
        # taking assault actions
        if not self.hasAssaulted:
            assaultTargets = {}

            for eny in self.unitData.units():
                if eny.faction != self.role and not eny.ineffective:
                    assaultUnits = set()
                    for unt in self.unitData.units():
                        if unt.faction == self.role and unt.canMove and unt.currentStrength >= MIN_ASSAULT_STRENGTH:
                            moveTargets = unt.findMoveTargets(self.mapData, self.unitData)
                            for hex in moveTargets:
                                distance = map.gridDistance(hex.x_grid, hex.y_grid, eny.hex.x_grid, eny.hex.y_grid)
                                if distance <= combat.range[unt.type]:
                                    assaultUnits.add(unt.uniqueId)
                                    break
                    if len(assaultUnits) > 0:
                        assaultTargets[eny.uniqueId] = assaultUnits

            while len(assaultTargets.keys()) > 0:
                min_size = float('inf')
                min_key = None
                for key in assaultTargets.keys():
                    size = len(assaultTargets[key])
                    if size < min_size:
                        min_size = size
                        min_key = key

                # check that assault group is not greater than the MAX_GROUPSIZE due to performance limitations
                if len(assaultTargets[min_key]) > MAX_GROUPSIZE:
                    subsets = set(itertools.combinations(assaultTargets[min_key], MAX_GROUPSIZE))
                    for subset in subsets:
                        best_actions, assault_score = self.getBestAssaultGroupAssaultActions(game, state, set(subset), enyNextHexId)
                        if assault_score > 1 and self.role == "blue":     
                            return best_actions
                        if assault_score < -1 and self.role == "red":
                            return best_actions
                    assaultTargets.pop(min_key)
                else:
                    best_actions, assault_score = self.getBestAssaultGroupAssaultActions(game, state, assaultTargets[min_key], enyNextHexId)
                    if assault_score > 1 and self.role == "blue":     
                        return best_actions
                    if assault_score < -1 and self.role == "red":
                        return best_actions
                    assaultTargets.pop(min_key)

        self.hasAssaulted = True              

        #--------------------------------------------------------------------
        # taking maneuver actions
        remainingPhases = math.ceil((self.param["score"]["maxPhases"] - state["status"]["phaseCount"]) / 2)

        for unt in self.unitData.units():
            if unt.faction == self.role and unt.canMove and not unt.ineffective:
                action = self.getBestUnitManeuverAction(unt, remainingPhases, enyNextHexId)
                if action:
                    return [action]
            
        return [{"type":"pass"}]
    
    def process(self, message, response_fn=None):
        msgD = json.loads(message)
        ######### Change this function to create new AIs ########  
        if msgD['type'] == "parameters":
            self.param = msgD['parameters']
            self.mapData = map.MapData()
            self.unitData = unit.UnitData()
            map.fromPortable(self.param['map'], self.mapData)
            unit.fromPortable(self.param['units'], self.unitData, self.mapData)
            responseD = { "type":"role-request", "role":self.role }
            self.action_queue = []
            self.doSetup = True
        elif msgD['type'] == 'observation':
            obs = msgD['observation']
            if not obs['status']['isTerminal'] and obs['status']['onMove'] == self.role:
                if obs['status']['setupMode']:
                    # Update status and unit data based on observation
                    self.statusData = status.Status.fromPortable(obs["status"], self.param, self.mapData)
                    for unitObs in obs['units']:
                        uniqueId = unitObs['faction'] + " " + unitObs['longName']
                        un = self.unitData.unitIndex[ uniqueId ]
                        un.partialObsUpdate( unitObs, self.unitData, self.mapData )
                    if self.doSetup:
                        self.action_queue = self._setupActions(obs['status']['cityOwner'])
                        self.doSetup = False
                    if len(self.action_queue)>0:
                        unit_id, hex_id = self.action_queue.pop()
                        if hex_id in self.unitData.occupancy and len(self.unitData.occupancy[hex_id])>0:
                            # Setup hex is occupied. Switch the units
                            actionD = {"type":"setup-exchange","mover":unit_id,"friendly":self.unitData.occupancy[hex_id][0].uniqueId}                      
                        else:
                            # Setup hex is empty. Just move there.
                            actionD = {"type":"setup-move","mover":unit_id,"destination":hex_id}
                    else:
                        # All setup actions have been taken
                        actionD = {"type":"pass"}
                    responseD = {"type":"action", "action":actionD}
                else:
                    # update status data (i.e. CityOwnerD)
                    self.statusData = status.Status.fromPortable(obs["status"], self.param, self.mapData)
          
                    if not self.best_action_list:
                        game = Game(self.param)
                        state = {}
                        state["status"] = obs["status"]
                        for unitObs in obs['units']:
                            uniqueId = unitObs['faction'] + " " + unitObs['longName']
                            un = self.unitData.unitIndex[ uniqueId ]
                            un.partialObsUpdate( unitObs, self.unitData, self.mapData )
                        state["units"] = self.unitData.toPortable()
                        
                        self.best_action_list = self.getPendingUnitsNextActions(game, state)
                    responseD = { "type":"action", "action":self.best_action_list.pop() }
            else:
                self.hasAssaulted = False
                responseD = None
        elif msgD['type'] == 'reset':
            responseD = None
            self.action_queue = []
            self.doSetup = True
        if responseD:
            return json.dumps(responseD)
 

async def client(ai, uri):
    async with websockets.connect(uri) as websocket:
        while True:
            message = await websocket.recv()
            print(f"Message received by AI over websocket: {message[:100]}")
            result = ai.process(message)
            if result:
                await websocket.send( result )

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("faction")
    parser.add_argument("--uri")
    args = parser.parse_args()
    
    ai = AI(args.faction)
    uri = args.uri
    if not uri:
        uri = "ws://localhost:9999"
    asyncio.get_event_loop().run_until_complete(client(ai, uri))
    
 